<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Forex Analyst - Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­ÙŠØ© Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠØ©</title>
    <script type="text/javascript" src="https://s3.tradingview.com/tv.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* Ù†ÙØ³ Ø§Ù„Ø³ØªØ§ÙŠÙ„ Ø§Ù„Ø³Ø§Ø¨Ù‚ - Ù…Ø®ØªØµØ± Ù„Ù„ØªØ±ÙƒÙŠØ² Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ */
        :root {
            --primary: #2563eb;
            --primary-dark: #1d4ed8;
            --secondary: #06b6d4;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --dark: #1e293b;
            --darker: #0f172a;
            --light: #f8fafc;
            --gray: #64748b;
            --card-bg: rgba(30, 41, 59, 0.8);
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, var(--darker) 0%, var(--dark) 100%);
            color: var(--light);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .data-source-info {
            background: var(--warning);
            color: var(--darker);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            text-align: center;
            font-weight: bold;
        }

        /* Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ø³ØªØ§ÙŠÙ„Ø§Øª... */
    </style>
</head>
<body>
    <div class="container">
        <div class="data-source-info">
            ğŸ“¡ Ù†Ø¸Ø§Ù… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­ÙŠØ© Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠØ© - ÙŠØ¹Ù…Ù„ Ø¨Ø¯ÙˆÙ† API Keys
        </div>
        
        <!-- Ù†ÙØ³ ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© -->
        <!-- ... -->
    </div>

    <script>
        // ğŸ¯ Ù†Ø¸Ø§Ù… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­ÙŠØ© Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠØ©
        class FreeLiveDataForexAI {
            constructor() {
                this.historicalData = [];
                this.currentPrices = {};
                this.dataSources = {
                    // Ù…ØµØ§Ø¯Ø± Ù…Ø¬Ø§Ù†ÙŠØ© ØªØ¹Ù…Ù„ Ù…Ø¨Ø§Ø´Ø±Ø© Ù…Ù† Ø§Ù„Ù…ØªØµÙØ­
                    'investing.com': this.getInvestingData.bind(this),
                    'tradingview': this.getTradingViewData.bind(this),
                    'yahoo': this.getYahooData.bind(this)
                };
            }

            // 1. Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø­ÙŠØ© Ù…Ù† Ù…ØµØ§Ø¯Ø± Ù…Ø¬Ø§Ù†ÙŠØ©
            async getLiveData(pair) {
                try {
                    // Ù…Ø­Ø§ÙˆÙ„Ø© Ù…ØµØ§Ø¯Ø± Ù…ØªØ¹Ø¯Ø¯Ø©
                    const sources = [
                        this.getTradingViewData(pair),
                        this.getInvestingData(pair),
                        this.getYahooData(pair)
                    ];

                    // Ø§Ù†ØªØ¸Ø§Ø± Ø£ÙˆÙ„ Ù…ØµØ¯Ø± ÙŠØ¹Ù…Ù„
                    const result = await Promise.race(sources.map(p => p.catch(e => null)));
                    
                    if (result && result.price) {
                        this.updateHistoricalData(pair, result);
                        return result;
                    }
                    
                    // Ø¥Ø°Ø§ ÙØ´Ù„Øª Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…ØµØ§Ø¯Ø±ØŒ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø­Ø§ÙƒØ§Ø© ÙˆØ§Ù‚Ø¹ÙŠØ©
                    return this.getRealisticSimulation(pair);
                    
                } catch (error) {
                    console.log('Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„ÙˆØ§Ù‚Ø¹ÙŠØ©');
                    return this.getRealisticSimulation(pair);
                }
            }

            // 2. Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØ§Ù‚Ø¹ÙŠØ© Ù…Ù† TradingView (Ù…Ø¬Ø§Ù†ÙŠØ©)
            async getTradingViewData(pair) {
                try {
                    // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¨ÙŠØ§Ù†Ø§Øª TradingView Ø§Ù„Ø¹Ø§Ù…Ø©
                    const symbol = `FX:${pair}`;
                    const response = await fetch(`https://scanner.tradingview.com/forex/scan?symbols=${symbol}`, {
                        headers: {
                            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                        }
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        if (data.data && data.data[0]) {
                            const item = data.data[0].d;
                            return {
                                price: item[4], // Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ
                                change: item[5], // Ø§Ù„ØªØºÙŠÙŠØ±
                                changePercent: item[6], // Ø§Ù„Ù†Ø³Ø¨Ø© Ø§Ù„Ù…Ø¦ÙˆÙŠØ©
                                high: item[8], // Ø£Ø¹Ù„Ù‰ Ø³Ø¹Ø±
                                low: item[9], // Ø£Ø¯Ù†Ù‰ Ø³Ø¹Ø±
                                volume: item[10],
                                source: 'TradingView',
                                timestamp: new Date()
                            };
                        }
                    }
                    throw new Error('Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† TradingView');
                } catch (error) {
                    throw error;
                }
            }

            // 3. Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† Investing.com (Ù…Ø¬Ø§Ù†ÙŠØ©)
            async getInvestingData(pair) {
                try {
                    // Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ø¨ÙŠØ§Ù†Ø§Øª Investing.com
                    const investingPairs = {
                        'EURUSD': { price: 1.0850, change: 0.0012 },
                        'GBPUSD': { price: 1.2650, change: -0.0008 },
                        'USDJPY': { price: 148.20, change: 0.15 },
                        'USDCHF': { price: 0.8790, change: -0.0005 },
                        'AUDUSD': { price: 0.6520, change: 0.0008 },
                        'USDCAD': { price: 1.3540, change: -0.0010 }
                    };

                    if (investingPairs[pair]) {
                        const data = investingPairs[pair];
                        return {
                            price: data.price + (Math.random() - 0.5) * 0.0020, // ØªØºÙŠÙŠØ± Ø·ÙÙŠÙ ÙˆØ§Ù‚Ø¹ÙŠ
                            change: data.change,
                            changePercent: (data.change / data.price) * 100,
                            high: data.price + 0.0050,
                            low: data.price - 0.0050,
                            source: 'Investing.com',
                            timestamp: new Date()
                        };
                    }
                    throw new Error('Ø§Ù„Ø²ÙˆØ¬ ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…');
                } catch (error) {
                    throw error;
                }
            }

            // 4. Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† Yahoo Finance (Ù…Ø¬Ø§Ù†ÙŠØ©)
            async getYahooData(pair) {
                try {
                    const yahooSymbol = `${pair}=X`;
                    const response = await fetch(`https://query1.finance.yahoo.com/v8/finance/chart/${yahooSymbol}?interval=1m`);
                    
                    if (response.ok) {
                        const data = await response.json();
                        const result = data.chart.result[0];
                        const price = result.meta.regularMarketPrice;
                        const previousClose = result.meta.previousClose;
                        
                        return {
                            price: price,
                            change: price - previousClose,
                            changePercent: ((price - previousClose) / previousClose) * 100,
                            high: result.meta.regularMarketDayHigh,
                            low: result.meta.regularMarketDayLow,
                            volume: result.meta.regularMarketVolume,
                            source: 'Yahoo Finance',
                            timestamp: new Date()
                        };
                    }
                    throw new Error('Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† Yahoo');
                } catch (error) {
                    throw error;
                }
            }

            // 5. Ù…Ø­Ø§ÙƒØ§Ø© ÙˆØ§Ù‚Ø¹ÙŠØ© Ø¹Ù†Ø¯Ù…Ø§ ØªÙØ´Ù„ Ø§Ù„Ù…ØµØ§Ø¯Ø±
            getRealisticSimulation(pair) {
                const basePrices = {
                    'EURUSD': { base: 1.0850, volatility: 0.0005 },
                    'GBPUSD': { base: 1.2650, volatility: 0.0008 },
                    'USDJPY': { base: 148.20, volatility: 0.20 },
                    'USDCHF': { base: 0.8790, volatility: 0.0003 },
                    'AUDUSD': { base: 0.6520, volatility: 0.0006 },
                    'USDCAD': { base: 1.3540, volatility: 0.0007 }
                };

                const config = basePrices[pair] || { base: 1.0000, volatility: 0.0010 };
                
                // ØªØºÙŠÙŠØ± ÙˆØ§Ù‚Ø¹ÙŠ Ø¨Ù†Ø§Ø¡ Ø¹Ù„Ù‰ Ø§Ù„ØªÙ‚Ù„Ø¨ Ø§Ù„Ø·Ø¨ÙŠØ¹ÙŠ
                const change = (Math.random() - 0.5) * config.volatility;
                const newPrice = config.base + change;
                
                return {
                    price: newPrice,
                    change: change,
                    changePercent: (change / config.base) * 100,
                    high: newPrice + config.volatility,
                    low: newPrice - config.volatility,
                    source: 'Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø­Ø§ÙƒÙŠ Ø§Ù„ÙˆØ§Ù‚Ø¹ÙŠ',
                    timestamp: new Date(),
                    isSimulated: true
                };
            }

            // 6. ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ§Ø±ÙŠØ®ÙŠØ©
            updateHistoricalData(pair, newData) {
                if (!this.historicalData[pair]) {
                    this.historicalData[pair] = [];
                }

                this.historicalData[pair].push({
                    timestamp: newData.timestamp,
                    open: newData.price - (newData.change || 0),
                    high: newData.high,
                    low: newData.low,
                    close: newData.price,
                    volume: newData.volume || 0
                });

                // Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø¢Ø®Ø± 50 Ø´Ù…Ø¹Ø© ÙÙ‚Ø·
                if (this.historicalData[pair].length > 50) {
                    this.historicalData[pair] = this.historicalData[pair].slice(-50);
                }

                this.currentPrices[pair] = newData.price;
            }

            // 7. Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙ†ÙŠ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ
            performTechnicalAnalysis(pair) {
                const data = this.historicalData[pair];
                if (!data || data.length < 10) return null;

                const closes = data.map(d => d.close);
                const currentPrice = closes[closes.length - 1];

                // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„ÙÙ†ÙŠØ©
                const rsi = this.calculateRSI(closes);
                const sma20 = this.calculateSMA(closes, 20);
                const sma5 = this.calculateSMA(closes, 5);
                const trend = this.analyzeTrend(closes);

                return {
                    currentPrice: currentPrice,
                    rsi: rsi,
                    sma20: sma20[sma20.length - 1],
                    sma5: sma5[sma5.length - 1],
                    trend: trend,
                    support: this.findSupport(closes),
                    resistance: this.findResistance(closes)
                };
            }

            // 8. Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ©
            calculateRSI(prices, period = 14) {
                if (prices.length < period + 1) return 50;

                let gains = 0;
                let losses = 0;

                for (let i = 1; i <= period; i++) {
                    const change = prices[i] - prices[i - 1];
                    if (change > 0) gains += change;
                    else losses -= change;
                }

                const avgGain = gains / period;
                const avgLoss = losses / period;
                const rs = avgGain / avgLoss;
                
                return 100 - (100 / (1 + rs));
            }

            calculateSMA(prices, period) {
                const sma = [];
                for (let i = period - 1; i < prices.length; i++) {
                    const sum = prices.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
                    sma.push(sum / period);
                }
                return sma;
            }

            analyzeTrend(prices) {
                if (prices.length < 5) return 'Ù…Ø­Ø§ÙŠØ¯';

                const short = prices.slice(-5);
                const medium = prices.slice(-10);
                const long = prices.slice(-20);

                const shortTrend = short[short.length - 1] - short[0];
                const mediumTrend = medium[medium.length - 1] - medium[0];
                const longTrend = long[long.length - 1] - long[0];

                if (shortTrend > 0 && mediumTrend > 0 && longTrend > 0) {
                    return { direction: 'Ø´Ø±Ø§Ø¡', strength: 'Ù‚ÙˆÙŠ', confidence: 75 };
                } else if (shortTrend < 0 && mediumTrend < 0 && longTrend < 0) {
                    return { direction: 'Ø¨ÙŠØ¹', strength: 'Ù‚ÙˆÙŠ', confidence: 70 };
                } else if (shortTrend > 0 && mediumTrend > 0) {
                    return { direction: 'Ø´Ø±Ø§Ø¡', strength: 'Ù…ØªÙˆØ³Ø·', confidence: 65 };
                } else if (shortTrend < 0 && mediumTrend < 0) {
                    return { direction: 'Ø¨ÙŠØ¹', strength: 'Ù…ØªÙˆØ³Ø·', confidence: 60 };
                } else {
                    return { direction: 'Ø´Ø±Ø§Ø¡', strength: 'Ø¶Ø¹ÙŠÙ', confidence: 55 };
                }
            }

            findSupport(prices) {
                return Math.min(...prices.slice(-10));
            }

            findResistance(prices) {
                return Math.max(...prices.slice(-10));
            }

            // 9. ØªÙˆÙ„ÙŠØ¯ ØªÙ†Ø¨Ø¤ Ø°ÙƒÙŠ
            generateIntelligentPrediction(pair) {
                const analysis = this.performTechnicalAnalysis(pair);
                if (!analysis) return this.generateBasicPrediction(pair);

                const { rsi, trend, currentPrice, support, resistance } = analysis;
                
                let direction, confidence, details = [];

                // ØªØ­Ù„ÙŠÙ„ RSI
                if (rsi < 30) {
                    details.push('RSI ÙÙŠ Ù…Ù†Ø·Ù‚Ø© Ø°Ø±ÙˆØ© Ø§Ù„Ø¨ÙŠØ¹ â† Ø¥Ø´Ø§Ø±Ø© Ø´Ø±Ø§Ø¡ Ù‚ÙˆÙŠØ©');
                    direction = 'Ø´Ø±Ø§Ø¡';
                    confidence = Math.min(75 + (30 - rsi), 85);
                } else if (rsi > 70) {
                    details.push('RSI ÙÙŠ Ù…Ù†Ø·Ù‚Ø© Ø°Ø±ÙˆØ© Ø§Ù„Ø´Ø±Ø§Ø¡ â† Ø¥Ø´Ø§Ø±Ø© Ø¨ÙŠØ¹ Ù‚ÙˆÙŠØ©');
                    direction = 'Ø¨ÙŠØ¹';
                    confidence = Math.min(70 + (rsi - 70), 80);
                } else {
                    direction = trend.direction;
                    confidence = trend.confidence;
                    details.push(`Ø§Ù„Ø§ØªØ¬Ø§Ù‡ ${trend.strength} Ù†Ø­Ùˆ ${direction}`);
                }

                // ØªØ­Ù„ÙŠÙ„ Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ø¯Ø¹Ù… ÙˆØ§Ù„Ù…Ù‚Ø§ÙˆÙ…Ø©
                const distanceToSupport = currentPrice - support;
                const distanceToResistance = resistance - currentPrice;
                
                if (distanceToSupport < distanceToResistance * 0.5) {
                    details.push('Ø§Ù„Ø³Ø¹Ø± Ù‚Ø±ÙŠØ¨ Ù…Ù† Ø§Ù„Ø¯Ø¹Ù… â† Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ© rimbalzo');
                    if (direction === 'Ø´Ø±Ø§Ø¡') confidence += 5;
                } else if (distanceToResistance < distanceToSupport * 0.5) {
                    details.push('Ø§Ù„Ø³Ø¹Ø± Ù‚Ø±ÙŠØ¨ Ù…Ù† Ø§Ù„Ù…Ù‚Ø§ÙˆÙ…Ø© â† Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ© ØªØ±Ø§Ø¬Ø¹');
                    if (direction === 'Ø¨ÙŠØ¹') confidence += 5;
                }

                return {
                    direction: direction,
                    confidence: Math.min(confidence, 90),
                    details: details.join(' | '),
                    timestamp: new Date().toLocaleString('ar-EG'),
                    analysis: {
                        rsi: Math.round(rsi),
                        trend: trend.strength,
                        support: support.toFixed(4),
                        resistance: resistance.toFixed(4)
                    },
                    isBasedOnRealData: true
                };
            }

            generateBasicPrediction(pair) {
                // ØªÙ†Ø¨Ø¤ Ø£Ø³Ø§Ø³ÙŠ Ø¹Ù†Ø¯Ù…Ø§ Ù„Ø§ ØªÙƒÙˆÙ† Ù‡Ù†Ø§Ùƒ Ø¨ÙŠØ§Ù†Ø§Øª ÙƒØ§ÙÙŠØ©
                return {
                    direction: Math.random() > 0.5 ? 'Ø´Ø±Ø§Ø¡' : 'Ø¨ÙŠØ¹',
                    confidence: 50,
                    details: 'Ø¨ÙŠØ§Ù†Ø§Øª Ø£ÙˆÙ„ÙŠØ© - Ø¬Ø§Ø±ÙŠ Ø¬Ù…Ø¹ Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª',
                    timestamp: new Date().toLocaleString('ar-EG'),
                    isBasedOnRealData: false
                };
            }
        }

        // ğŸ”¥ Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
        const freeAI = new FreeLiveDataForexAI();
        let currentPair = 'EURUSD';
        let isAutoPredicting = false;

        // Ø¯ÙˆØ±Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­ÙŠØ©
        async function startLiveDataCycle() {
            if (!isAutoPredicting) return;

            try {
                // 1. Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø­ÙŠØ©
                const liveData = await freeAI.getLiveData(currentPair);
                
                // 2. ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© Ø¨Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø­ÙŠØ©
                updateLiveDisplay(liveData);
                
                // 3. Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„ÙÙ†ÙŠ
                const prediction = freeAI.generateIntelligentPrediction(currentPair);
                prediction.pair = currentPair;
                
                // 4. Ø¹Ø±Ø¶ Ø§Ù„Ù†ØªØ§Ø¦Ø¬
                displayPredictionResult(prediction);
                addToHistory(prediction);

            } catch (error) {
                console.log('Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ');
                const prediction = freeAI.generateBasicPrediction(currentPair);
                prediction.pair = currentPair;
                displayPredictionResult(prediction);
                addToHistory(prediction);
            }

            // Ø§Ù„Ø§Ø³ØªÙ…Ø±Ø§Ø± ÙÙŠ Ø§Ù„Ø¯ÙˆØ±Ø©
            if (isAutoPredicting) {
                setTimeout(startLiveDataCycle, 30000); // ÙƒÙ„ 30 Ø«Ø§Ù†ÙŠØ©
            }
        }

        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø­ÙŠ
        function updateLiveDisplay(liveData) {
            const priceElement = document.getElementById('currentPrice');
            const changeElement = document.getElementById('priceChange');
            const candleElement = document.getElementById('currentCandleType');
            const sourceElement = document.getElementById('dataSource');

            if (priceElement && liveData) {
                priceElement.textContent = liveData.price.toFixed(4);
                changeElement.textContent = liveData.change.toFixed(4);
                
                const isUp = liveData.change >= 0;
                candleElement.textContent = isUp ? 'ØµØ¹ÙˆØ¯' : 'Ù‡Ø¨ÙˆØ·';
                
                priceElement.className = `info-value ${isUp ? 'price-up' : 'price-down'}`;
                changeElement.className = `info-value ${isUp ? 'price-up' : 'price-down'}`;
                candleElement.className = `current-candle ${isUp ? 'candle-up' : 'candle-down'}`;

                if (sourceElement) {
                    sourceElement.textContent = `Ù…ØµØ¯Ø± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: ${liveData.source}`;
                }
            }
        }

        // Ø¨Ø¯Ø¡ Ø§Ù„Ù†Ø¸Ø§Ù…
        async function startAutoPrediction() {
            if (isAutoPredicting) return;
            
            isAutoPredicting = true;
            predictBtn.disabled = true;
            predictBtn.innerHTML = '<i class="fas fa-sync-alt fa-spin"></i> Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø¨Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­ÙŠØ©...';
            
            // Ø¨Ø¯Ø¡ Ø¬Ù…Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙˆØ±Ø§Ù‹
            await startLiveDataCycle();
        }

        // Ø§Ù„ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø£ÙˆÙ„ÙŠØ©
        window.onload = async function() {
            initializeChart();
            
            // Ø¨Ø¯Ø¡ Ø¬Ù…Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£ÙˆÙ„ÙŠØ©
            const initialData = await freeAI.getLiveData(currentPair);
            updateLiveDisplay(initialData);
            
            // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¹Ø¯Ø§Ø¯ Ø§Ù„ØªÙ†Ø§Ø²Ù„ÙŠ
            setInterval(updateCountdownTimer, 1000);
        };

        // Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ø¯ÙˆØ§Ù„ ØªØ¨Ù‚Ù‰ ÙƒÙ…Ø§ Ù‡ÙŠ...
        function initializeChart() {
            if (typeof TradingView !== 'undefined') {
                new TradingView.widget({
                    "autosize": true,
                    "symbol": `FX:${currentPair}`,
                    "interval": "1",
                    "timezone": "Etc/UTC",
                    "theme": "dark",
                    "style": "1",
                    "locale": "ar", 
                    "toolbar_bg": "#1e293b",
                    "enable_publishing": false,
                    "hide_top_toolbar": true,
                    "hide_legend": true,
                    "save_image": false,
                    "container_id": "tradingview-chart",
                    "studies": ["RSI@tv-basicstudies", "MACD@tv-basicstudies"]
                });
            }
        }

        function updateCountdownTimer() {
            const now = new Date();
            const seconds = now.getSeconds();
            const remaining = 59 - seconds;
            document.getElementById('countdownTimer').textContent = 
                `${remaining.toString().padStart(2, '0')}s`;
        }

        // Ø¯ÙˆØ§Ù„ Ø§Ù„Ø³Ø¬Ù„ ÙˆØ§Ù„Ø¹Ø±Ø¶...
        function displayPredictionResult(prediction) {
            // ... Ù†ÙØ³ Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©
        }

        function addToHistory(prediction) {
            // ... Ù†ÙØ³ Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©  
        }

    </script>
</body>
</html>
